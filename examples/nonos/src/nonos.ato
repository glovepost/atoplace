#pragma experiment("BRIDGE_CONNECT")
#pragma experiment("FOR_LOOP")

import ElectricPower
import ElectricLogic
import I2S
import UART
import I2C
import USB2_0
import Capacitor
import Resistor

from "atopile/st-stusb4500/st-stusb4500.ato" import STUSB4500
from "atopile/rpi-cm5/cm5.ato" import CM5
from "atopile/ti-tps54560x/ti-tps54560x.ato" import TI_TPS54560
from "atopile/saleae-header/saleae-header.ato" import SaleaeHeaderVertical
from "atopile/ti-tas5825mrhbr/ti_tas5825mrhbr.ato" import Texas_Instruments_TAS5825MRHBR_driver
from "atopile/adi-adau145x/adau145x.ato" import Analog_Devices_ADAU145x_driver
from "atopile/ti-tlv75901/ti-tlv75901.ato" import TLV75901_driver
from "parts/Kyocera_AVX_04025A8R2JAT2A/Kyocera_AVX_04025A8R2JAT2A.ato" import Kyocera_AVX_04025A8R2JAT2A_package

from "parts/JST_Sales_America_B02B_XASK_1_A_LF__SN/JST_Sales_America_B02B_XASK_1_A_LF__SN.ato" import JST_Sales_America_B02B_XASK_1_A_LF__SN_package
from "parts/TE_Connectivity_1_2328702_0/TE_Connectivity_1_2328702_0.ato" import TE_Connectivity_1_2328702_0_package
from "parts/HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04/HCTL_HC_TYPE_C_24P_Driver.ato" import HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04_driver
from "parts/Honor_Elec_RVT1H470M0607/Honor_Elec_RVT1H470M0607.ato" import Honor_Elec_RVT1H470M0607_package


module NONOS:
    """
    An opensource sonos era 100 clone
    """

    # Components
    cm5 = new CM5
    regulator_5v = new TI_TPS54560
    regulator_3v3 = new TLV75901_driver
    amplifier = new Texas_Instruments_TAS5825MRHBR_driver
    pd_controller = new STUSB4500
    usb_connector = new HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04_driver
    dsp = new Analog_Devices_ADAU145x_driver

    # Connectors
    board_to_board_connector = new TE_Connectivity_1_2328702_0_package
    full_range_speaker_connector = new JST_Sales_America_B02B_XASK_1_A_LF__SN_package
    tweeter_speaker_connector = new JST_Sales_America_B02B_XASK_1_A_LF__SN_package
    debug_headers = new SaleaeHeaderVertical[3]

    # Power rails
    power_20v = new ElectricPower
    power_5v = new ElectricPower
    power_3v3 = new ElectricPower

    # Bulk capacitors for 20V rail
    bulk_cap_20v = new Honor_Elec_RVT1H470M0607_package[4]
    for bulk_cap in bulk_cap_20v:
        power_20v.vcc ~ bulk_cap.1
        power_20v.gnd ~ bulk_cap.2

    # Specify voltages on power rails
    power_5v.voltage = 5.1V +/- 3%
    power_3v3.voltage = 3.3V +/- 5%

    # addressing
    pd_controller.i2c.address = 0x28 # Why is this here? Should be in package

    # substitute default pd_controller.usb_connector
    # pd_controller.usb_connector.exclude_from_bom = True # maybe useful for debugging
    usb_connector.power_vbus ~ pd_controller.pd_controller.power_vbus
    usb_connector.cc[0] ~ pd_controller.pd_controller.cc1
    usb_connector.cc[1] ~ pd_controller.pd_controller.cc2
    # usb_connector.usb2 ~ pd_controller.usb2
    pd_controller.i2c ~ cm5.i2cs[0]

    # TOOD: make this work instead
    # pd_controller.usb_connector -> HCTL_HC_TYPE_C_24P_VS9_3_5A_F1_1_04

    # Power supply connections
    pd_controller.power_out ~ power_20v
    power_20v ~> regulator_5v ~> power_5v
    power_5v ~> regulator_3v3 ~> power_3v3

    # Power for devices
    power_5v ~ cm5.power_5v
    power_3v3 ~ dsp.power
    power_3v3 ~ pd_controller.power_mcu
    power_20v ~ amplifier.power_pvdd
    power_3v3 ~ amplifier.power_dvdd

    # Regulator compensation tweak for part availability
    regulator_5v.compensation_capacitors[1].capacitance = 20pF +/- 10%
    regulator_5v.compensation_capacitors[1].package = "0402"

    # amplifier
    cm5.i2cs[0] ~ amplifier.i2c
    cm5.cm5.gpio[24] ~ amplifier.mute
    cm5.cm5.gpio[25] ~ amplifier.warn
    cm5.cm5.gpio[5] ~ amplifier.fault
    cm5.cm5.gpio[6] ~ amplifier.pdn

    # speaker outputs
    amplifier.output_a.p.line ~ full_range_speaker_connector.1
    amplifier.output_a.n.line ~ full_range_speaker_connector.2
    amplifier.output_b.p.line ~ tweeter_speaker_connector.2
    amplifier.output_b.n.line ~ tweeter_speaker_connector.1

    # Hat Connector - Inverted pinout (relative to hat)
    board_to_board_connector.10 ~ cm5.i2cs[1].sda.line
    board_to_board_connector.9 ~ cm5.i2cs[1].scl.line
    board_to_board_connector.8 ~ power_5v.vcc
    board_to_board_connector.7 ~ power_5v.gnd
    board_to_board_connector.6 ~ power_3v3.vcc
    board_to_board_connector.5 ~ power_3v3.gnd
    board_to_board_connector.4 ~ cm5.cm5.gpio[16].line # nfc.reset.line
    board_to_board_connector.3 ~ cm5.cm5.gpio[17].line # nfc.interrupt.line
    board_to_board_connector.2 ~ cm5.cm5.gpio[22].line # touch.interrupt.line
    board_to_board_connector.1 ~ cm5.cm5.gpio[23].line # led_data.line

    # dsp
    dsp.reset_disable ~ cm5.cm5.gpio[20]  # TODO: which pin?
    dsp.model.i2c ~ cm5.i2cs[0]

    # workaround for incorrect .required in dsp package
    _pll_mclk = new ElectricLogic
    dsp.pll_mclk ~ _pll_mclk

    # TODO: review
    # TODO: cm5 I2S interface
    cm5_i2s = new I2S
    cm5_i2s.sck ~ cm5.cm5.gpio[18]
    cm5_i2s.ws ~ cm5.cm5.gpio[19]
    cm5_i2s.sd ~ cm5.cm5.gpio[21]
    cm5_i2s ~ dsp.model.i2s_ins[0]
    dsp.model.i2s_outs[0] ~ amplifier.i2s

    # debug headers
    debug_uart = new UART
    # cm5.uart0 ~ debug_uart
    cm5.uart0.base_uart.tx ~ debug_headers[0].channels[3]
    cm5.uart0.base_uart.rx ~ debug_headers[0].channels[2]
    power_5v.hv ~ debug_headers[0].channels[1].line
    power_3v3.hv ~ debug_headers[0].channels[0].line
    power_3v3.lv ~ debug_headers[0].channels[0].reference_shim.lv

    debug_i2c = new I2C
    # cm5.i2cs[0] ~ debug_i2c
    cm5.i2cs[0].scl ~ debug_headers[1].channels[3]
    cm5.i2cs[0].sda ~ debug_headers[1].channels[2]
    cm5.cm5.hdi_a.pins[17] ~ debug_headers[1].channels[1].line # Ethernet sync_out
    power_3v3.lv ~ debug_headers[1].channels[0].reference_shim.lv

    debug_i2s = new I2S
    cm5_i2s ~ debug_i2s
    debug_i2s.sck ~ debug_headers[2].channels[3]
    debug_i2s.ws ~ debug_headers[2].channels[2]
    debug_i2s.sd ~ debug_headers[2].channels[1]
    power_3v3.lv ~ debug_headers[2].channels[0].reference_shim.lv

    # ADAU Addressing
    addr_resistors = new Resistor[2]
    dsp.model.addressor.address_lines[0].line ~> addr_resistors[0] ~> power_3v3.vcc
    dsp.model.addressor.address_lines[1].line ~> addr_resistors[1] ~> power_3v3.vcc
    # dsp.model.i2c.address = 0x3B # seems to be broken :(
    for resistor in addr_resistors:
        resistor.value = 10kohm +/- 1%
        resistor.package = "0402"

    # Net names
    cm5.cm5.gpio[16].line.override_net_name = "nfc_reset"
    cm5.cm5.gpio[17].line.override_net_name = "nfc_interrupt"
    cm5.cm5.gpio[22].line.override_net_name = "touch_interrupt"
    cm5.cm5.gpio[23].line.override_net_name = "led_data"
    amplifier.mute.line.override_net_name = "amp_mute"
    amplifier.warn.line.override_net_name = "amp_warn"
    amplifier.fault.line.override_net_name = "amp_fault"
    amplifier.pdn.line.override_net_name = "amp_pdn"
    amplifier.i2s.sck.line.override_net_name = "amp_i2s_sck"
    amplifier.i2s.ws.line.override_net_name = "amp_i2s_ws"
    amplifier.i2s.sd.line.override_net_name = "amp_i2s_sd"
    power_20v.vcc.override_net_name = "20v_vcc"
    power_5v.vcc.override_net_name = "5v_vcc"
    power_3v3.vcc.override_net_name = "3v3_vcc"
    power_3v3.gnd.override_net_name = "gnd"
    amplifier.output_a.p.line.override_net_name = "spkr_full_p"
    amplifier.output_a.n.line.override_net_name = "spkr_full_n"
    amplifier.output_b.p.line.override_net_name = "spkr_tweet_p"
    amplifier.output_b.n.line.override_net_name = "spkr_tweet_n"
    cm5.boot_mode_switch.input.line.override_net_name = "boot_mode"
    cm5.power_button_switch.input.line.override_net_name = "power_button"
    dsp.reset_disable.line.override_net_name = "dsp_reset_disable"
    cm5.cm5.hdi_a.pins[17].override_net_name = "eth_sync_out"
