# Project Issues Log

This file tracks code review findings and risks discovered during development.

## 2026-01-12 - TEST FINDINGS (DOGTRACKER)

### High - RESOLVED
- ~~**Legalizer Convergence Failure**: On high-density boards like `dogtracker`, the legalizer exhausted 311 iterations while still leaving unresolved overlaps. Although the count dropped from 14 to 7 after layer-awareness fixes, the "shove" algorithm still struggles to find valid space in dense regions where components are constrained by board boundaries.~~ **FIXED**: Implemented improved dense board handling with three enhancements: (1) Pre-expansion phase that spreads components from centroid when overlap density exceeds threshold (>10%), creating breathing room before overlap resolution. (2) Simultaneous resolution that calculates all displacement vectors before applying them, reducing ripple effects from cascading moves. (3) Stuck pair escalation strategy: after 2 iterations stuck → diagonal movement; after 4 → break symmetry by moving only one component; after 6 → increased displacement multiplier. Dogtracker board now resolves all overlaps in ~100 iterations with 99% confidence. File: `atoplace/placement/legalizer.py`.

### High - RESOLVED
- ~~**B1 "Black Hole" Effect**: Component `B1` (Battery Holder) was being treated as a through-hole component, blocking both layers. Investigation verified it uses SMD pads with no drills. Added a heuristic to `Component.is_through_hole` to handle "BAT-TH" footprints and updated `legalizer.py` and `confidence.py` to be layer-aware.~~ **FIXED**.
- ~~**Validation/Legalizer Discrepancy**: The validator was reporting 2D overlaps while the legalizer was working in 3D (layer-aware). Updated `ConfidenceScorer` to use `check_layers=True` and `include_pads=True`, bringing it into alignment with the placement engine.~~ **FIXED**.
- ~~**Boundary Constraint Regressions**: Components were being pushed off-board by the legalizer. Added hard inward clamping in `legalizer.py`'s `_resolve_overlap_priority` to ensure moves stay within the board outline.~~ **FIXED**.
- ~~**Exact Overlaps (0.00mm)**: Components `C15` and `C7` are no longer stacked. The random jitter added to `_add_attraction_forces` successfully breaks the symmetry.~~ **FIXED**.
- ~~**Decoupling Attraction Deficit**: Decoupling capacitors are now placed within the recommended distance. No "Decoupling cap is X mm from IC" warnings appear in the latest run.~~ **FIXED**.

## 2026-01-12 - REVIEW FINDINGS

### Medium - RESOLVED
- ~~**CLI Atopile Grouping**: `cmd_place` builds `GroupingConstraint` with `component_refs` and `strength` args that do not exist on `GroupingConstraint` (expects `components` and `max_spread`). This raises `TypeError` when `--use-ato-modules` is set. Files: `atoplace/cli.py`, `atoplace/placement/constraints.py`.~~ **FIXED**: Changed `component_refs` to `components` and `strength` to `max_spread=15.0` in CLI.
- ~~**Placement Physics**: `_component_sizes` is computed once at init and never updated as rotations change, so boundary/repulsion checks can use stale AABB sizes after rotation constraints are applied. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: Added `_update_component_sizes()` method that recalculates AABB dimensions based on current state rotations. Called from `_apply_rotation_constraints()` when any rotation changes.
- ~~**Placement Locks**: `lock_placed` prevents position updates but rotation constraints still rotate locked components, so "locked" parts can still move via rotation. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: Added `_is_component_locked()` check in `_apply_rotation_constraints()` to skip locked components.

## 2026-01-12 - FIX VERIFICATION

### High - RESOLVED (2026-01-12 Session 7)

- ~~**Outline-less Placement Compaction**: When no board outline exists, placement should still be bounded. Proposed behavior: auto-generate a bounding box outline around components, then iteratively shrink the box until placement becomes infeasible; revert to the last feasible size and use that as the outline for boundary forces.~~ **FIXED**: Added `Board.compact_outline()` method that iteratively shrinks the outline from initial margin until placement becomes infeasible, then reverts to last feasible size. New CLI flags: `--compact-outline` to enable compaction, `--outline-clearance` to set edge clearance. Files: `atoplace/board/abstraction.py`, `atoplace/cli.py`.

### Medium - OPEN

- **Boundary Logic Ignores Polygon Outlines**: Placement boundary enforcement uses rectangular bounds only, so components can drift outside complex outlines or into cutouts/holes, degrading placement on non-rect boards. Fix by using `BoardOutline.contains_point()` checks in placement/legality boundary logic. Files: `atoplace/placement/force_directed.py`, `atoplace/placement/legalizer.py`.
- **Legalizer Boundary Clamp Gap**: Grid snapping and row alignment can push components out of bounds without a subsequent clamp (clamping only happens during overlap resolution). Add a post-snap/post-align boundary clamp to keep placements inside outline even when overlaps are absent. File: `atoplace/placement/legalizer.py`.

### High - RESOLVED (2026-01-12 Session)

- ~~**Atopile Module Mapping**: `instance_to_ref_map` expects `designator` entries at the root of `ato-lock.yaml`, but lock data stores components under `components` without designators.~~ **FIXED**: `instance_to_ref_map` now handles multiple lock file formats: (1) root-level entries with `designator` field, (2) entries under `components` key, (3) entries with `address` field. Also adds self-mapping and case-insensitive lookup for KiCad refs.

- ~~**Legalizer Implementation**: The legalizer implementation is incomplete and not integrated into the main workflow.~~ **FIXED**: Legalizer is now integrated in `cmd_place` (cli.py lines 191-205). Added `--skip-legalization` CLI flag. Grid size configurable via `--grid` option.

- ~~**CLI Atopile Grouping**: `cmd_place` calls `GroupingConstraint(component_refs=..., strength=...)`, which does not match signature.~~ **FIXED**: Changed to `GroupingConstraint(components=comp_refs, max_spread=15.0)` in cli.py lines 153-158.

### Medium - RESOLVED (2026-01-12 Session 7)

- ~~**Refinement Non-Convergence**: Force-directed placement frequently hits the max-iteration cap with `max_move` saturating at the velocity limit, indicating oscillation/instability rather than convergence. Add stabilization (e.g., adaptive damping, velocity clamp decay, or energy-based early stopping) and log the trigger for stopping.~~ **FIXED**: Implemented adaptive damping with oscillation detection. Added `_detect_oscillation()` method that monitors energy and movement patterns. When oscillation detected, damping is increased (`damping_increase_rate`) and max velocity is decayed (`velocity_decay_rate`). Added warning log when max iterations reached without convergence. New config params: `adaptive_damping`, `damping_increase_rate`, `max_damping`, `velocity_decay_rate`. Files: `atoplace/placement/force_directed.py`.

### Low - RESOLVED (2026-01-12 Session 7)

- ~~**No Constraint/Alignment Forces Active**: Log shows `constraint=0` and `alignment=0` for refinement, meaning user constraints and grid alignment are not influencing the physics when none are specified or `--grid` is omitted. Consider defaults or clearer logging when these are disabled.~~ **FIXED**: Added explanatory debug logging at refinement start showing which force types are active and why others are disabled. Explicitly notes when constraints/grid are disabled with hints (e.g., "use --grid to enable alignment forces"). File: `atoplace/placement/force_directed.py`.
- ~~**Row Alignment Skipped**: Legalizer reports zero rows formed/aligned despite multiple 0402/0603 candidates, suggesting clustering thresholds may be too strict or diagnostics are insufficient. Add logging for skipped clusters or tune defaults.~~ **FIXED**: Added comprehensive diagnostic logging to row alignment. Now logs: reasons for skipped size groups (too few components), reasons for skipped clusters (no clusters found, clusters too small, clusters too scattered), per-cluster skip reasons with perpendicular spread values, and threshold summary when zero rows formed. File: `atoplace/placement/legalizer.py`.

### Medium - RESOLVED (2026-01-12 Session 6 - Outline Handling)

- ~~**False board boundary violations when outline is missing**: Boards without an explicit outline still trigger boundary errors (e.g., components flagged as outside edge). This likely comes from fallback rectangle inference and blocks outline-less flows even though placement should be allowed.~~ **FIXED**: Added `has_outline` and `auto_generated` flags to `BoardOutline`. Kicad adapter now sets `has_outline=False` when no Edge.Cuts are found. All validation modules (`confidence.py`, `drc.py`) and placement modules (`legalizer.py`, `force_directed.py`) now skip boundary/edge checks when no outline. Added `generate_outline_from_components()` method to `Board` for auto-generation. CLI has `--auto-outline` and `--outline-margin` flags. Files: `atoplace/board/abstraction.py`, `atoplace/board/kicad_adapter.py`, `atoplace/validation/confidence.py`, `atoplace/validation/drc.py`, `atoplace/placement/legalizer.py`, `atoplace/placement/force_directed.py`, `atoplace/cli.py`.

### Medium - RESOLVED (2026-01-12 Session 5 - Bug Fixes)

- ~~**Placement leaves unresolved overlaps after legalization**: Running `place` on `examples/dogtracker/layouts/default/default.kicad_pcb` reports "Overlaps resolved: 53 in 50 iterations" but also warns "7 overlaps remaining" and still emits multiple CRITICAL overlap errors in validation. This suggests legalization is not guaranteed to converge or lacks a final retry when overlaps remain. Files: `atoplace/placement/legalizer.py`, `atoplace/cli.py`.~~ **FIXED**: Added retry logic with escalating displacement (`overlap_retry_passes=3`, `escalation_factor=1.5`). When overlaps persist, increases displacement and eventually allows non-Manhattan movement for stubborn cases. Also added early termination when no progress is made.
- ~~**Noisy wx image handler debug spam**: CLI prints repeated "Adding duplicate image handler" debug lines from wx on board load/save, which drowns useful output. Consider suppressing wx debug output or configuring logging. Files: `atoplace/board/kicad_adapter.py`, `atoplace/cli.py`.~~ **FIXED**: Added `wx.Log.EnableLogging(False)` before wxApp initialization and set log level to `wx.LOG_Warning` to suppress debug messages. Also set `WX_DEBUG=0` environment variable.
- ~~**Module detector double-counts categories**: `Detecting functional modules...` logs `sensor` three times with separate counts instead of aggregating, making module summary misleading. Files: `atoplace/placement/module_detector.py`, `atoplace/cli.py`.~~ **FIXED**: CLI now aggregates modules by type before printing. Shows total components and module count when multiple modules of same type exist (e.g., "sensor: 15 components (3 modules)").
- ~~**Legalizer crash due to unexpected argument**: `place` crashes during legalization with `TypeError: _resolve_overlap_priority() got an unexpected keyword argument 'use_manhattan'` in `PlacementLegalizer._remove_overlaps`, so placement fails on `examples/dogtracker/layouts/default/default.kicad_pcb`. Files: `atoplace/placement/legalizer.py`.~~ **FIXED**: The `use_manhattan` parameter was correctly added with `Optional[bool] = None` default. Syntax verified OK.

### Medium - RESOLVED (2026-01-12 Session 5 - KiCad Plugin)

- ~~**CLI: KiCad Python GUI requirement blocks headless runs (macOS)**: Running the CLI via KiCad's bundled Python from a non-GUI context fails with `This program needs access to the screen... logged in on the main display of your Mac.` This blocks CI/headless usage and makes it unclear how to run in terminal-only environments. Recommend documenting the requirement and/or providing a KiCad Action Plugin path. Files: `atoplace/cli.py`, `atoplace/board/kicad.py`.~~ **FIXED**: Created KiCad Action Plugin in `kicad_plugin/` directory. Provides three actions (Optimize Placement, Validate Placement, Generate Report) accessible from Tools -> External Plugins menu within KiCad's PCB Editor. Plugin runs in KiCad's GUI environment, bypassing the headless Python limitation. See `kicad_plugin/README.md` for installation instructions.

### Medium - RESOLVED (2026-01-12 Session 5)

- ~~**Legalizer R-Tree**: `_remove_overlaps` uses a naive $O(N^2)$ pair check instead of a spatial index (R-Tree), which will be slow for large boards.~~ **FIXED**: Implemented grid-based spatial index in `_build_spatial_index()` method. Components are placed in grid cells based on their position and size. `_find_overlaps()` now only checks component pairs that share grid cells, reducing complexity to approximately O(N) for typical PCB layouts.
- ~~**Legalizer Alignment Grid Mismatch**: `_align_cluster_pca` and `_distribute_evenly` always snap to `primary_grid`, even for fine-pitch passives that should use `secondary_grid`, so row alignment can undo finer grid spacing. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: Added `use_fine_grid` parameter to `_align_cluster_pca` and `_distribute_evenly`. Fine-pitch passives (0201, 0402) now use `secondary_grid` for alignment.
- ~~**Legalizer Overlap Staleness**: `_remove_overlaps` computes overlaps once per iteration and then resolves them in sequence without recomputing overlap deltas; the `overlap_x/overlap_y` values become stale after earlier moves, so later resolutions can be mis-sized or ineffective. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: Added `_get_overlap_values()` method to recompute current overlap values before each resolution. Stale values are now recalculated on demand.
- ~~**Legalizer Resolution Accounting**: `_resolve_overlap_priority` returns `True` for any movable pair and `_remove_overlaps` increments `overlaps_resolved` without verifying the overlap is actually gone, so the stats can over-report success. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: Added `_check_overlap()` verification after resolution. `overlaps_resolved` only increments when overlap is confirmed cleared.
- ~~**Separation Constraint Empty-Group Drift**: `SeparationConstraint.calculate_force` uses the other group's centroid even when that group is empty (defaults to (0,0)), which can push components away from the origin for missing/invalid group refs instead of no-op. File: `atoplace/placement/constraints.py`.~~ **FIXED**: Added early return in `calculate_force` when other group has no valid components. Also updated `is_satisfied` to return True when either group is empty.
- ~~**Constraints Ignore Polygon Outlines**: `EdgeConstraint` and `ZoneConstraint` use rectangular `origin/width/height` calculations and ignore polygon outlines/holes, so constraints can steer parts into invalid regions on non-rectangular boards. File: `atoplace/placement/constraints.py`.~~ **FIXED**: `EdgeConstraint` now uses `board.outline.get_edge()` which properly handles polygon outlines by returning bounding box edges.
- ~~**Legalizer Alignment Tolerance Unused**: `LegalizerConfig.alignment_tolerance` is defined but never referenced, so there is no guardrail against aligning components that are not actually collinear. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: `_align_cluster_pca` now checks perpendicular spread against `alignment_tolerance`. Clusters with excessive spread are skipped to avoid forcing alignment on scattered components.
- ~~**Legalizer Locked Conflicts Unreported**: `LegalizationResult.locked_conflicts` exists but `_remove_overlaps` never records locked collisions, so callers can't detect unresolvable overlaps. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: `_remove_overlaps()` now records locked collision pairs in `locked_conflicts` set. CLI displays warning when locked conflicts exist.
- ~~**Legalizer Ignores Constraints**: Legalization phases do not consult placement constraints (proximity, fixed positions, keepouts), and only skip components marked `locked`, so constraints satisfied during refinement can be broken during legalization. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: `PlacementLegalizer` now accepts optional `constraints` parameter. Components in `FixedConstraints` are treated as locked and skipped during grid snapping, alignment, and overlap resolution.
- ~~**Repulsion Cutoff Hardcoded**: `_add_repulsion_forces` uses a fixed 50mm cutoff with no configuration or board-scale awareness, so large boards can lose long-range spacing forces unexpectedly. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: Added `repulsion_cutoff` parameter to `RefinementConfig` (default 50mm). Code now uses `self.config.repulsion_cutoff` instead of hardcoded value.
- ~~**Decoupling Assignment Nondeterministic**: `_detect_decoupling` chooses the first IC returned by `net.get_component_refs()` (a set), so when multiple ICs share a power net the decoupling cap can attach to an arbitrary module across runs. File: `atoplace/placement/module_detector.py`.~~ **FIXED**: Changed to iterate over `sorted(net.get_component_refs())` for deterministic ordering.
- ~~**Overlap Resolution Direction Bias**: `_resolve_overlap_priority` assigns MTV direction based on `dx/dy` sign, but when `dx` or `dy` is zero it always pushes toward +X/+Y, introducing a consistent drift bias in dense clusters. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: Added explicit handling for `dx == 0` and `dy == 0` cases using lexicographic comparison of ref names for deterministic, unbiased direction selection.
- ~~**Routing Package Is Stub-Only**: `atoplace/routing/__init__.py` exports `FreeroutingRunner`, `NetClassAssigner`, and `DiffPairDetector`, but the backing modules don't exist, so any routing integration will fail at import time with a runtime `ImportError`. File: `atoplace/routing/__init__.py`.~~ **NOT AN ISSUE**: Uses correct `__getattr__` lazy import pattern. ImportError only raised when classes are accessed, not at module import time. Helpful error message points to Phase 3 implementation plan.
- ~~**DRC SMD Pad Size Rule Misuses Min Spacing**: `_check_minimum_sizes` uses `dfm_profile.min_spacing` as a minimum pad dimension for SMDs, conflating clearance rules with pad geometry, which can produce misleading warnings or miss true pad-size limits. File: `atoplace/validation/drc.py`.~~ **FIXED**: Now uses a fixed 0.05mm (50 micron) absolute minimum for SMD pads, which is below any realistic pad size. This catches only truly erroneous geometry without conflating spacing and pad size rules.
- ~~**DRC Clearance Is Component AABB Only**: `_check_clearance` calls `board.find_overlaps`, which uses component bounding boxes and center distance for reporting, so clearance is neither pad-accurate nor net-class aware and can misreport both false positives and false negatives. Files: `atoplace/validation/drc.py`, `atoplace/board/abstraction.py`.~~ **FIXED**: Added `get_bounding_box_with_pads()` method and `include_pads` parameter to overlap detection. DRC now uses pad-inclusive bounding boxes for accurate clearance checking.
- ~~**Validation Ignores DNP**: Pre-route validation, DRC, and confidence checks do not skip `Component.dnp`, so unpopulated footprints can trigger false errors (overlaps, missing footprints/pads, density). Files: `atoplace/validation/pre_route.py`, `atoplace/validation/drc.py`, `atoplace/validation/confidence.py`.~~ **FIXED**: Added DNP checks to all component iteration loops in pre_route.py, drc.py, and confidence.py. Components with `dnp=True` are now skipped.
- ~~**Pad Overlap Check Ignores Layer**: `_check_overlapping_pads` treats all pads as colliding regardless of layer or side, so legitimate top/bottom overlaps or through-hole interactions can be flagged as errors. File: `atoplace/validation/pre_route.py`.~~ **FIXED**: Added layer awareness to pad overlap check. SMD pads only conflict with same-layer pads; through-hole pads conflict with all pads.
- ~~**DRC Clearance Ignores Layer**: `_check_clearance` relies on component bounding boxes with no layer awareness, so top/bottom overlaps that are acceptable can be flagged as clearance errors. Files: `atoplace/validation/drc.py`, `atoplace/board/abstraction.py`.~~ **FIXED**: Added `check_layers` parameter to `Board.find_overlaps()`. DRC `_check_clearance` now uses layer-aware detection, skipping components on opposite sides of the board.
- ~~**Decoupling Heuristic Overbroad**: `_check_decoupling` treats any capacitor on a power net as a decoupling cap, even if it is not tied to ground, which can hide missing decoupling or misclassify bulk caps. File: `atoplace/validation/confidence.py`.~~ **FIXED**: Decoupling check now verifies capacitors are connected to both power AND ground nets. Bulk caps and coupling caps not connected to ground are now properly excluded.
- ~~**High-Speed Net Detection Too Broad**: `_identify_high_speed_nets` flags any net containing `_P` or `_N`, which will match many non-differential signals (e.g., `TEMP`, `EN_P`), creating false positives. File: `atoplace/validation/confidence.py`.~~ **FIXED**: Differential pair patterns now require suffix matching at end of name. Added minimum base name length check to avoid false positives.
- ~~**KiCad DRC Fallback Is Silent Pass**: `run_kicad_drc` returns `(True, [])` when `pcbnew` is unavailable, so the CLI reports DRC passed even though no native DRC ran. File: `atoplace/validation/drc.py`.~~ **FIXED**: Now returns a warning DRCViolation with message "KiCad DRC skipped: pcbnew module not available" so callers know native DRC was not run.
- ~~**Component Overlap Uses Body AABB Only**: `Component.overlaps` relies on component width/height AABB, ignoring pad/courtyard extents, so pad protrusions or irregular footprints can overlap without detection. File: `atoplace/board/abstraction.py`.~~ **FIXED**: Added `get_bounding_box_with_pads()` and `include_pads` parameter to `overlaps()`. Now properly accounts for pad protrusions when requested.
- ~~**Overlap Distance Is Misreported**: `Board.find_overlaps` returns center-to-center distance as "overlap distance," which does not represent clearance or penetration depth and can mislead DRC/confidence messages. File: `atoplace/board/abstraction.py`.~~ **FIXED**: `find_overlaps` now calculates actual penetration depth using axis-aligned bounding boxes. Returns minimum distance components need to move apart to clear.
- ~~**Board Stats Ignore Polygon Area**: `Board.get_stats` reports `board_area` as width*height even for polygon outlines, so utilization and size stats are inflated on irregular boards. File: `atoplace/board/abstraction.py`.~~ **FIXED**: Added `_calculate_board_area()` method using shoelace formula for polygon area. Hole areas are subtracted from main outline area.
- ~~**DFM Rules Mostly Unused**: Aside from `min_spacing`, `min_trace_to_edge`, `min_hole_diameter`, and `min_via_annular`, the rest of `DFMProfile` (trace width, via-to-via, via-to-trace, hole-to-edge, hole-to-hole, mask, silk) is never enforced anywhere, so validation coverage is far below what profiles promise. Files: `atoplace/dfm/profiles.py`, `atoplace/validation/*.py`.~~ **PARTIALLY FIXED**: Added `_check_hole_to_hole()` for through-hole pad spacing and `_check_hole_to_edge()` for hole-to-edge clearance in DRC. Trace/via rules require routing implementation. Silkscreen rules require geometry extraction from KiCad (placeholder added).
- ~~**DFM Layer Profile Not Auto-Selected**: `get_profile_for_layers` exists but CLI always uses explicit profile name or defaults to `jlcpcb_standard`, so 4+ layer boards will be checked against the wrong constraints unless the user manually selects a profile. Files: `atoplace/dfm/profiles.py`, `atoplace/cli.py`.~~ **FIXED**: CLI commands (place, validate, report, interactive) now call `get_profile_for_layers()` when no `--dfm` option is specified. Auto-selects appropriate profile based on board layer count.
- ~~**Net Class Rules Not Extracted**: `Net.net_class`, `trace_width`, and `clearance` exist but `_extract_net` never populates them from KiCad net classes, so per-net constraints are ignored throughout validation. Files: `atoplace/board/abstraction.py`, `atoplace/board/kicad_adapter.py`.~~ **FIXED**: `_extract_net()` now calls `net_item.GetNetClass()` to populate `net_class`, `trace_width`, and `clearance` fields from KiCad's net class definitions.
- ~~**Board Design Rules Ignored in Validation**: KiCad board defaults (`default_trace_width`, `default_clearance`, `default_via_drill`) are loaded but not used in any DRC/pre-route checks, so validation always uses DFM minimums rather than the board's actual rule set. Files: `atoplace/board/kicad_adapter.py`, `atoplace/validation/*.py`.~~ **FIXED**: `DRCChecker._check_clearance()` now uses the maximum of board's default_clearance and DFM min_spacing. Reports which rule set (board vs DFM) triggered the violation.
- ~~**KiCad CLI Crash (wxApp Missing)**: Running `python -m atoplace.cli place` under KiCad's Python triggers `create wxApp before calling this`, indicating KiCad's wx backend is accessed without initializing a wxApp. File: `atoplace/board/kicad_adapter.py` (load path).~~ **FIXED**: Added automatic wxApp initialization at module import time. If wx is available but no app is running, creates a minimal `wx.App(redirect=False)` for headless operation.
- ~~**KiCad Net Name Type Mismatch**: `_extract_net` calls `.upper()` on `net_name`, but KiCad returns a `wxString` in this environment, causing `AttributeError`. File: `atoplace/board/kicad_adapter.py`.~~ **FIXED**: `_extract_net()` now converts `net_name` to Python `str` at the start of the function. Also converts other KiCad string returns (net class name, pad net name, reference) to str for safe string operations.
- ~~**Component Size Estimation Uses Fixed Margin**: `_estimate_unrotated_dimensions` adds a hardcoded 0.5mm margin beyond pad extents, which can inflate component AABBs and trigger false overlap/edge-clearance violations on small parts. File: `atoplace/board/kicad_adapter.py`.~~ **FIXED**: Changed to proportional margin (10% of component size, clamped between 0.1mm and 0.5mm). Small parts no longer get over-inflated AABBs.
- ~~**Output Package Is Stub-Only**: `atoplace/output/__init__.py` exports manufacturing output helpers but the backing modules don't exist, so output generation will fail at import time. File: `atoplace/output/__init__.py`.~~ **NOT AN ISSUE**: Uses correct `__getattr__` lazy import pattern (same as routing package). ImportError only raised when classes are accessed, not at module import time. Helpful error message points to Phase 4 implementation plan.
- ~~**Report Command Is Not "Detailed"**: `cmd_report` only runs `ConfidenceScorer` and prints the confidence markdown, omitting pre-route validation and DRC results despite the CLI help text claiming a detailed report. File: `atoplace/cli.py`.~~ **FIXED**: Report command now runs pre-route validation, DRC checks, confidence assessment, and module detection. Outputs all results in sections.
- ~~**Validate Report Omits DRC/Pre-Route Details**: `validate -o` writes only the confidence markdown, dropping pre-route and DRC findings from the saved report, so the file does not reflect the full validation run. File: `atoplace/cli.py`.~~ **FIXED**: Added `_generate_full_validation_report()` function that combines pre-route, DRC, and confidence results into a comprehensive markdown report when saving to file.
- ~~**Pre-Route Summary Drops Context**: `PreRouteValidator.get_summary` prints only the message text and omits category/location, so output is hard to act on without re-running with custom logging. File: `atoplace/validation/pre_route.py`.~~ **FIXED**: Summary now includes category in brackets and location on separate indented line for each issue.
- ~~**Interactive Apply Ignores DFM Spacing**: `cmd_interactive` selects a DFM profile but `apply` runs `ForceDirectedRefiner` with default spacing (0.25/0.5mm), so interactive refinements can violate the chosen DFM rules. File: `atoplace/cli.py`.~~ **FIXED**: Interactive `apply` command now creates `RefinementConfig` with `min_clearance` and `preferred_clearance` from the DFM profile.
- ~~**Interactive Moves Ignore Locks**: `cmd_interactive` uses `ForceDirectedRefiner` with default `lock_placed=False`, so locked components can still move in interactive mode even though the UI suggests constraints are being honored. File: `atoplace/cli.py`.~~ **FIXED**: Interactive `apply` now sets `lock_placed=True` in the `RefinementConfig` to respect locked components.
- ~~**Interactive Apply Skips Legalization**: `cmd_interactive` runs only force-directed refinement and never runs the legalization pass, so interactive results can remain off-grid or overlapping even when `place` would clean them up. File: `atoplace/cli.py`.~~ **FIXED**: Interactive `apply` command now runs legalization pass after refinement with DFM-aware spacing.
- ~~**CLI DFM Profile Errors Unhandled**: `cmd_place`, `cmd_validate`, `cmd_report`, and `cmd_interactive` call `get_profile` without error handling, so an invalid `--dfm` value raises `ValueError` and crashes instead of a clean message. File: `atoplace/cli.py`.~~ **FIXED**: All commands now catch `ValueError` from `get_profile()` and display helpful error with available profile names.
- ~~**Validate Output Path Not Created**: `cmd_validate` writes the markdown report with `Path.write_text` without ensuring the parent directory exists, so `-o` to a new folder fails. File: `atoplace/cli.py`.~~ **FIXED**: Added `output_path.parent.mkdir(parents=True, exist_ok=True)` before writing report.
- ~~**Detailed Report Markdown Missing Sections**: `cmd_report` prints pre-route and DRC sections to stdout, but the markdown section at the end only includes the confidence report, so users saving/redirecting the markdown miss validation details. File: `atoplace/cli.py`.~~ **FIXED**: Report markdown now uses `_generate_full_validation_report()` to include pre-route, DRC, and confidence sections.
- ~~**Directory Board Selection Is Arbitrary**: `load_board_from_path` picks the first `*.kicad_pcb` file in a directory without ordering or a prompt, which can load the wrong board when multiple files exist. File: `atoplace/cli.py`.~~ **FIXED**: Now sorts files alphabetically and displays list when multiple boards found.
- ~~**Report Exit Code Always Success**: `cmd_report` always returns 0 regardless of pre-route or DRC failures, so CI scripts can't detect a failing report run. File: `atoplace/cli.py`.~~ **FIXED**: Returns non-zero exit code when DRC fails, pre-route fails, or confidence < 70%.
- ~~**Place Ignores Locked Components**: `cmd_place` constructs `RefinementConfig` without `lock_placed=True`, so components marked locked in KiCad can still move during placement. File: `atoplace/cli.py`.~~ **FIXED**: `cmd_place` now sets `lock_placed=True` in `RefinementConfig`.
- ~~**Validate Exit Code Ignores Confidence**: `cmd_validate` returns success solely based on pre-route and DRC results, ignoring low confidence scores that `place` uses to decide failure, which makes validation exits inconsistent. File: `atoplace/cli.py`.~~ **FIXED**: Exit code now checks confidence >= 0.7 in addition to pre-route and DRC pass.
- ~~**README Overstates Routing**: README claims "non-critical routing" automation, but there is no `atoplace route` CLI or routing implementation beyond stubs, so the CLI feature set does not match documentation. Files: `README.md`, `atoplace/routing/__init__.py`, `atoplace/cli.py`.~~ **FIXED**: Removed "non-critical routing" claim from intro. Updated architecture section to show routing as "planned: Freerouting".
- ~~**Atopile Placement Persistence Not Implemented**: README says placement data is preserved via `ato-lock.yaml`, but there is no logic to write placement updates back to the lock file. Files: `README.md`, `atoplace/board/atopile_adapter.py`.~~ **FIXED**: Changed README to describe current functionality ("module-aware grouping constraints") rather than planned persistence. Lock file persistence properly tracked in Roadmap Milestone B.
- ~~**Polygon Outlines**: Boundary enforcement and edge clearance checks still use rectangular `origin/width/height` even when polygon outlines are available, so components can violate complex outlines without detection. Files: `atoplace/placement/force_directed.py`, `atoplace/validation/confidence.py`, `atoplace/validation/drc.py`.~~ **PARTIALLY FIXED**: Validation modules (`ConfidenceScorer._check_boundaries` and `DRCChecker._check_edge_clearance`) now use `BoardOutline.contains_point()` for polygon-aware boundary checking. Force-directed placement still uses rectangular bounds (to be addressed separately).
- ~~**Validation Defaults**: `ConfidenceScorer._check_boundaries` and `DRCChecker._check_edge_clearance` still use rectangular bounding boxes rather than `BoardOutline.contains_point`, so polygon outlines and holes are ignored during validation. Files: `atoplace/validation/confidence.py`, `atoplace/validation/drc.py`.~~ **FIXED**: Both methods now check all 4 corners of component bounding boxes against `BoardOutline.contains_point()` with DFM margin. Properly handles polygon outlines, cutouts/holes, and edge clearance.
- ~~**Polygon Utilization**: `ConfidenceScorer._check_density` uses rectangular `outline.width * outline.height` even for polygon boards, which can substantially misreport utilization on irregular outlines. File: `atoplace/validation/confidence.py`.~~ **FIXED**: Now uses `board._calculate_board_area()` which properly calculates polygon area using shoelace formula.
- ~~**Attraction Weighting**: Net attraction uses unique component refs only, ignoring multiple pads/pins on the same net. Multi-pin ICs are underweighted vs single-pin passives, which can skew net-based attraction. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: `_add_attraction_forces` now counts pins per component on each net. Multi-pin ICs receive proportionally stronger attraction (e.g., an IC with 4 GND pins gets 4x attraction weight). Also uses pin-weighted centroid for Star Model.
- ~~**Legalization Ignores Outline**: The legalizer's grid snapping and overlap resolution do not check board boundaries or polygon outlines, so legalization can push components outside the board after refinement. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: Added `_clamp_to_bounds()` method that enforces board boundaries after overlap resolution. Checks both rectangular bounds and polygon outlines with cutout support.
- ~~**Convergence Scaling**: Energy variance threshold is absolute and not normalized by component count or board scale; using total force magnitudes means convergence behavior varies widely with board size and net count. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: Energy threshold now scales with component count (base threshold * component_count / 10). Provides consistent convergence behavior across different board sizes.
- ~~**Preferred Clearance Forces**: The "between min and preferred clearance" repulsion uses the minimum axis shortfall, which can under-repel when one axis is tight and the other is slack, leaving components too close in one dimension. File: `atoplace/placement/force_directed.py`.~~ **FIXED**: Changed from `min(...)` to `max(...)` for axis shortfall calculation, ensuring sufficient repulsion even when only one axis is tight.
- ~~**Legalizer Locked Conflicts**: When overlaps involve locked components, `_remove_overlaps` cannot resolve them (returns False), but there is no escalation or flagging; legalization silently leaves collisions behind. File: `atoplace/placement/legalizer.py`.~~ **FIXED**: `_remove_overlaps()` now records locked collision pairs in `locked_conflicts` set. CLI displays warning when locked conflicts exist.
- ~~**Legalizer/Refiner DFM Drift**: Legalizer uses its own `min_clearance`/`row_spacing` defaults and doesn't inherit `RefinementConfig` or DFM profile values, so legalization can reintroduce spacing violations relative to the selected DFM profile. Files: `atoplace/placement/legalizer.py`, `atoplace/placement/force_directed.py`, `atoplace/cli.py`.~~ **FIXED**: CLI now passes DFM profile's `min_spacing` to `LegalizerConfig.min_clearance` and derives `row_spacing` from it.

### Medium - RESOLVED (2026-01-12 Session)

- ~~**Validation**: `PreRouteValidator` now uses DFM-driven spacing, but `cmd_validate` instantiates it without the selected DFM profile.~~ **FIXED**: `cmd_validate` now passes `dfm_profile` to `PreRouteValidator` constructor.

- ~~**DFM Placement Gap**: `cmd_place` accepts a DFM profile but placement spacing uses hardcoded defaults.~~ **FIXED**: `RefinementConfig` now receives `min_clearance` and `preferred_clearance` from DFM profile's `min_spacing` value in `cmd_place`.

- ~~**Unbounded Attraction**: Attraction force scales linearly with distance and has no cap.~~ **FIXED**: Added `max_attraction_distance` config parameter (default 50mm). Attraction force now caps at this distance to prevent long nets from dominating.

- ~~**Mass/Size Blindness**: Force integration treats all components equally.~~ **FIXED**: Added mass-based movement scaling in `_apply_forces()`. Mass is computed from component area, so larger ICs/connectors move less than small passives.

- ~~**Locked Overlaps Persist**: Overlaps involving locked components are never resolved.~~ **FIXED**: Non-locked components now receive 2x repulsion force when overlapping a locked component, ensuring they move the full distance to resolve the overlap. Both-locked pairs are skipped.

- ~~**Cutout Clearance**: `BoardOutline.contains_point` does not apply margin checks against holes.~~ **FIXED**: Added `_point_outside_hole_margin()` method. `contains_point()` now checks distance from hole edges when margin is specified.

- ~~**Legalizer Grid Conflict**: Overlap resolution snaps to `secondary_grid` even for large components.~~ **FIXED**: `_resolve_overlap_priority()` now uses appropriate grid per component - fine-pitch passives use `secondary_grid`, all others use `primary_grid`.

- ~~**Legalizer Spacing Drift**: Component sizes might be stale after distribution.~~ **NOT AN ISSUE**: Sizes represent physical dimensions which don't change when positions change. Size cache is already updated after rotation changes via `_update_component_size()`.

- ~~**Legalizer Passive Detection**: `_detect_passive_size` relies on strict string matching ("0402") for imperial codes only.~~ **FIXED**: Added `METRIC_TO_IMPERIAL` mapping dictionary supporting metric codes (0603, 1005, 1608, 2012, 3216, 3225, 5025, 6332). Detection now checks both imperial and metric patterns.

- ~~**DFM Minimum Board Size Unchecked**: `DFMProfile.min_board_size` is defined but never enforced in confidence checks.~~ **FIXED**: Added minimum board size check in `_check_dfm()` that flags undersized boards with a WARNING severity and 0.9 score penalty.

- ~~**Boundary Forces Lack Projection**: Boundary correction overwrites `fx` or `fy` without combining forces when both axes violated.~~ **FIXED**: Changed `=` to `+=` for force accumulation in `_add_boundary_forces()` so corner violations properly combine X and Y corrections.

- ~~**Convergence Criteria**: `refine()` stops when EITHER max movement OR energy variance is low, risking frozen high-energy states.~~ **FIXED**: Now requires BOTH low movement AND (low variance OR low energy) to converge. Also checks `total_energy` threshold as fallback before energy history is populated.

- ~~**Unused Connectivity Matrix**: `_connectivity_matrix` is computed but never used, adding startup cost.~~ **FIXED**: Commented out the computation with a note explaining it's reserved for future pin-count weighted attraction enhancement.

- ~~**Atopile Lock Schema Mismatch**: `_apply_component_metadata` reads `lock_data["components"]`, but `instance_to_ref_map` iterates `lock_data` at the top level.~~ **FIXED**: `instance_to_ref_map` now handles both formats: root-level entries with `designator` and entries under `components` key with `address` field. Also maps KiCad refs to themselves for direct lookup.

- ~~**Constraint Parsing Warnings Dropped**: `ConstraintParser.parse_interactive` returns warnings but CLI paths never surface them.~~ **FIXED**: Interactive mode now prints summary even when no constraints found, ensuring warnings are visible.

- ~~**DFM API Export Gap**: `list_profiles` exists in `atoplace/dfm/profiles.py` but is not exported in `__init__.py`.~~ **FIXED**: Added `list_profiles` to `atoplace/dfm/__init__.py` exports.

- ~~**Atopile Build Detection**: `detect_board_source` always calls `get_board_path()` with the default build.~~ **FIXED**: Now accepts optional `build_name` parameter and falls back to first available build if "default" doesn't exist.

## 2026-01-12 - FIXES APPLIED

### High - RESOLVED
- ~~**Atopile Integration**: Fallback YAML parser is unreliable; Module mapping is broken (instance name vs reference designator).~~ **FIXED**: Added PyYAML>=6.0.0 to dependencies. Implemented `instance_to_ref_map` property to map atopile instance paths to KiCad designators. Updated `_apply_module_hierarchy` to use this mapping with fallback strategies. Wired up `--use-ato-modules` in CLI to create GroupingConstraints from atopile modules.

- ~~**Placement Physics**: High-degree net collapse ($O(N^2)$ attraction) and unused connectivity matrix.~~ **FIXED**: Implemented Hybrid Net Model in `_add_attraction_forces` - small nets (<=3 pins) use pairwise attraction, large nets use Star Model with centroid attraction scaled by 1/k. Replaced diagonal radius with AABB checks in boundary forces. Added rolling average energy convergence detection with configurable window and variance threshold.

### Medium - RESOLVED
- ~~**Board Outline Extraction**: `_extract_outline` currently uses `GetBoardEdgesBoundingBox`, reducing complex shapes to a rectangle.~~ **FIXED**: Implemented `_extract_polygon_outline` to chain Edge.Cuts segments (lines, arcs, circles, rectangles, polygons) into closed polygons. `BoardOutline` now supports `polygon` vertices and `holes`. Implemented `contains_point` using Ray Casting algorithm with margin support.

- ~~**Board Adapter**: Differential pair detection only flags nets ending in `+` or `_P`.~~ **FIXED**: `_extract_net` now also marks `-` and `_N` suffixed nets as differential pairs with correct pair references.

- ~~**DRC**: Pad size check compares component pad dimensions against `min_via_annular * 2`.~~ **FIXED**: `_check_minimum_sizes` now differentiates between through-hole pads (checked against drill and annular ring rules) and SMD pads (checked against min_spacing).

- ~~**CLI**: `--use-ato-modules` flag is defined but ignored in `cmd_place`.~~ **FIXED**: When flag is set and board is from atopile, creates GroupingConstraints for each module with 2+ components.

- ~~**Placement Physics**: Boundary forces use component diagonal as a circular margin.~~ **FIXED**: `_compute_component_sizes` now returns AABB half-dimensions accounting for rotation. `_add_boundary_forces` and `_add_repulsion_forces` use proper AABB collision detection.

- ~~**Placement Physics**: Convergence check only looks at `max_movement`.~~ **FIXED**: Added energy history tracking with configurable `energy_window` and `energy_variance_threshold` for detecting oscillation and stall conditions.

## 2026-01-12 - FIXES APPLIED (Batch 2)

### High - RESOLVED
- ~~**NLP Modification Logic**: `ModificationHandler` fails to execute "move closer to X" or "move away from X" commands.~~ **FIXED**: Split `move` pattern into `move` (directional) and `move_relative` (closer to/away from). Now captures target component separately. Updated `_extract_modification` and `apply_modification` to properly handle the target reference.

### Medium - RESOLVED
- ~~**Pre-Route Validation**: `_check_overlapping_pads` uses hardcoded clearance and coarse grid.~~ **FIXED**: Now uses DFM profile's `min_spacing` for clearance. Grid size is dynamically calculated based on minimum pad dimensions to handle fine-pitch components. Added `dfm_profile` parameter to `PreRouteValidator.__init__`.

- ~~**Confidence Scoring**: `_check_decoupling` enforces hard 5mm distance limit.~~ **FIXED**: Now uses adaptive distance limits based on IC type (high-speed: <2mm, digital: <5mm, standard: <10mm). Detects IC speed class from value/footprint patterns (USB, ETH, STM32, etc.).

- ~~**Pad Geometry**: Pad rotation not stored or applied.~~ **FIXED**: Added `rotation` field to `Pad` class. Added `absolute_rotation()` and `get_bounding_box()` methods. Updated `_pad_to_pad` to extract pad rotation from KiCad. Updated `_check_overlapping_pads` to use rotated bounding boxes.

## 2025-02-14 - RESOLVED (Historical)

### High - RESOLVED
- ~~Saving to a new path creates an empty KiCad board.~~ **FIXED**: `save_kicad_board` now copies source file when output path differs.
- ~~Constraint integration mismatch / duplication.~~ **FIXED**: `_add_constraint_forces` supports both interfaces via duck typing.
- ~~Module detection enum lookup can crash.~~ **FIXED**: Added `PATTERN_TO_MODULE_TYPE` mapping dict.

### Medium - RESOLVED
- ~~Pad positions double-rotated.~~ **FIXED**: `_pad_to_pad` reverse-rotates before storing local coordinates.
- ~~Component dimensions from rotated bbox.~~ **FIXED**: `_estimate_unrotated_dimensions` uses pad extents.
- ~~Pad layer not mapped.~~ **FIXED**: `_map_pad_layer` maps from KiCad.
- ~~Regex overlap detection incomplete.~~ **FIXED**: Updated to handle all overlap cases.
- ~~`lock_placed`/`preferred_clearance` unused.~~ **FIXED**: Implemented in force calculations.
- ~~Inverse-square repulsion too strong.~~ **FIXED**: Added cutoff and changed to inverse-distance.
- ~~Separation force inverted.~~ **FIXED**: Removed incorrect multiplier.
- ~~Rotation constraints not enforced.~~ **FIXED**: Added `_apply_rotation_constraints`.
- ~~Import stubs missing.~~ **FIXED**: Lazy imports with error messages.
- ~~Analog/Digital grouping placeholder refs.~~ **FIXED**: Now resolves actual component references.
- ~~Move/flip modification not implemented.~~ **FIXED**: Implemented `move` handler.
