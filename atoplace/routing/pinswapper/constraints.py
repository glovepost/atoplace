"""Constraint file generation for FPGA and PCB design tools.

Generates constraint updates reflecting pin swaps:
- XDC files for Xilinx Vivado
- QSF files for Intel Quartus
- TCL scripts for flexible integration
- Netlist patch files for PCB updates

These outputs allow the FPGA/schematic to match the optimized pin assignments
that were determined based on PCB routing considerations.
"""

import logging
from dataclasses import dataclass, field
from typing import List, Dict, Optional
from pathlib import Path
from enum import Enum
from datetime import datetime

from .optimizer import SwapAssignment, MatchingResult

logger = logging.getLogger(__name__)


class ConstraintFormat(Enum):
    """Output formats for constraint files."""
    XDC = "xdc"          # Xilinx Vivado
    QSF = "qsf"          # Intel Quartus
    TCL = "tcl"          # Generic TCL script
    NETLIST = "netlist"  # Netlist patch (CSV)
    JSON = "json"        # JSON for automation


@dataclass
class ConstraintUpdate:
    """A single constraint update entry."""
    signal_name: str
    old_pin: str
    new_pin: str
    component_ref: str
    package_pin: Optional[str] = None  # FPGA package pin name

    def to_xdc(self) -> str:
        """Generate XDC constraint line."""
        pin_name = self.package_pin or self.new_pin
        return f'set_property PACKAGE_PIN {pin_name} [get_ports {{{self.signal_name}}}]'

    def to_qsf(self) -> str:
        """Generate QSF constraint line."""
        pin_name = self.package_pin or self.new_pin
        return f'set_location_assignment {pin_name} -to {self.signal_name}'

    def to_tcl(self) -> str:
        """Generate TCL constraint command."""
        pin_name = self.package_pin or self.new_pin
        return f'assign_pin {{{self.signal_name}}} {pin_name}'


@dataclass
class ConstraintFile:
    """A complete constraint file with updates."""
    format: ConstraintFormat
    updates: List[ConstraintUpdate] = field(default_factory=list)
    header_comment: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    def render(self) -> str:
        """Render the constraint file as a string."""
        if self.format == ConstraintFormat.XDC:
            return self._render_xdc()
        elif self.format == ConstraintFormat.QSF:
            return self._render_qsf()
        elif self.format == ConstraintFormat.TCL:
            return self._render_tcl()
        elif self.format == ConstraintFormat.NETLIST:
            return self._render_netlist()
        elif self.format == ConstraintFormat.JSON:
            return self._render_json()
        else:
            raise ValueError(f"Unknown format: {self.format}")

    def _render_xdc(self) -> str:
        """Render as Xilinx XDC format."""
        lines = [
            f"# Pin Swap Constraints - Generated by AtoPlace",
            f"# Date: {self.timestamp}",
            f"# {self.header_comment}" if self.header_comment else "",
            "",
            "# ============================================================",
            "# Pin Location Constraints",
            "# ============================================================",
            "",
        ]

        for update in self.updates:
            lines.append(f"# {update.signal_name}: {update.old_pin} -> {update.new_pin}")
            lines.append(update.to_xdc())
            lines.append("")

        return "\n".join(lines)

    def _render_qsf(self) -> str:
        """Render as Intel Quartus QSF format."""
        lines = [
            f"# Pin Swap Constraints - Generated by AtoPlace",
            f"# Date: {self.timestamp}",
            f"# {self.header_comment}" if self.header_comment else "",
            "",
            "#============================================================",
            "# Pin Location Assignments",
            "#============================================================",
            "",
        ]

        for update in self.updates:
            lines.append(f"# {update.signal_name}: {update.old_pin} -> {update.new_pin}")
            lines.append(update.to_qsf())
            lines.append("")

        return "\n".join(lines)

    def _render_tcl(self) -> str:
        """Render as generic TCL script."""
        lines = [
            f"# Pin Swap Script - Generated by AtoPlace",
            f"# Date: {self.timestamp}",
            f"# {self.header_comment}" if self.header_comment else "",
            "",
            "# This script applies pin swaps to your design.",
            "# Source it in your EDA tool's TCL console.",
            "",
            "proc apply_pin_swaps {} {",
        ]

        for update in self.updates:
            lines.append(f"    # {update.signal_name}: {update.old_pin} -> {update.new_pin}")
            lines.append(f"    {update.to_tcl()}")

        lines.append("}")
        lines.append("")
        lines.append("# Uncomment to apply:")
        lines.append("# apply_pin_swaps")

        return "\n".join(lines)

    def _render_netlist(self) -> str:
        """Render as CSV netlist patch."""
        lines = [
            "# Pin Swap Netlist Patch - Generated by AtoPlace",
            f"# Date: {self.timestamp}",
            f"# {self.header_comment}" if self.header_comment else "",
            "",
            "Component,Signal,OldPin,NewPin",
        ]

        for update in self.updates:
            lines.append(
                f"{update.component_ref},{update.signal_name},"
                f"{update.old_pin},{update.new_pin}"
            )

        return "\n".join(lines)

    def _render_json(self) -> str:
        """Render as JSON for automation."""
        import json

        data = {
            "generator": "AtoPlace Pin Swapper",
            "timestamp": self.timestamp,
            "comment": self.header_comment,
            "updates": [
                {
                    "signal": u.signal_name,
                    "component": u.component_ref,
                    "old_pin": u.old_pin,
                    "new_pin": u.new_pin,
                    "package_pin": u.package_pin
                }
                for u in self.updates
            ]
        }

        return json.dumps(data, indent=2)


class ConstraintGenerator:
    """Generates constraint files from pin swap results.

    Translates optimized pin assignments into format-specific constraint files
    that can be used to update FPGA designs or PCB netlists.
    """

    def __init__(self, board: "Board"):
        """
        Initialize generator.

        Args:
            board: Board abstraction
        """
        self.board = board
        self._updates: List[ConstraintUpdate] = []

    def add_result(self, result: MatchingResult, component_ref: str):
        """
        Add pin swap assignments from optimization result.

        Args:
            result: Matching result with assignments
            component_ref: Component reference designator
        """
        for assignment in result.assignments:
            # Skip no-ops
            if assignment.from_pin == assignment.to_pin:
                continue

            update = ConstraintUpdate(
                signal_name=assignment.net,
                old_pin=assignment.from_pin,
                new_pin=assignment.to_pin,
                component_ref=component_ref,
                package_pin=self._get_package_pin(component_ref, assignment.to_pin)
            )
            self._updates.append(update)

    def _get_package_pin(self, ref: str, pad_number: str) -> Optional[str]:
        """Get FPGA package pin name for a pad if available."""
        comp = self.board.get_component(ref)
        if not comp:
            return None

        # Try to find package pin in component properties
        pad = comp.get_pad_by_number(pad_number)
        if not pad:
            return None

        # Check if pad number looks like a package pin (e.g., "AB12")
        if len(pad_number) >= 2 and pad_number[0].isalpha():
            return pad_number

        # Check component properties for pin mapping
        pin_key = f"PIN_{pad_number}"
        if pin_key in comp.properties:
            return comp.properties[pin_key]

        return None

    def generate(
        self,
        format: ConstraintFormat,
        comment: str = ""
    ) -> ConstraintFile:
        """
        Generate a constraint file.

        Args:
            format: Output format
            comment: Optional header comment

        Returns:
            ConstraintFile ready to render or save
        """
        return ConstraintFile(
            format=format,
            updates=self._updates.copy(),
            header_comment=comment
        )

    def save(
        self,
        path: Path,
        format: Optional[ConstraintFormat] = None,
        comment: str = ""
    ):
        """
        Save constraint file to disk.

        Args:
            path: Output file path
            format: Output format (auto-detected from extension if not specified)
            comment: Optional header comment
        """
        if format is None:
            format = self._detect_format(path)

        constraint_file = self.generate(format, comment)
        content = constraint_file.render()

        path = Path(path)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content)

        logger.info(f"Saved {len(self._updates)} pin swap constraints to {path}")

    def _detect_format(self, path: Path) -> ConstraintFormat:
        """Detect constraint format from file extension."""
        ext = Path(path).suffix.lower()

        format_map = {
            '.xdc': ConstraintFormat.XDC,
            '.qsf': ConstraintFormat.QSF,
            '.tcl': ConstraintFormat.TCL,
            '.csv': ConstraintFormat.NETLIST,
            '.json': ConstraintFormat.JSON,
        }

        if ext in format_map:
            return format_map[ext]

        raise ValueError(f"Cannot detect format from extension: {ext}")

    def clear(self):
        """Clear all accumulated updates."""
        self._updates = []

    @property
    def updates(self) -> List[ConstraintUpdate]:
        """Get all accumulated updates."""
        return self._updates

    @property
    def update_count(self) -> int:
        """Get count of pending updates."""
        return len(self._updates)
